[TOC]



## 第一章 markdown语法

[markdown基本语法](https://www.jianshu.com/p/q81RER) 

### 1.标题

一级标题(# )快捷键Ctrl+1

六级标题(###### )快捷键Ctrl+6

### 2.链接（ctrl+k）

按住Ctrl键并点击链接名就可以直接访问[^ 1]

> 2.1行内式链接：\[链接名\][链接网址]

[ssh配置](http://www.chengbenchao.top/git-tutorial/728370)



> 2.2参考式链接：\[CSDN\]:[CSDN网址]
>
> [CSDN网址]:http://www.csdn.net/



> 2.3自动链接：<网址>

<http://github.com>



### 3.引用

\>+空格：表示一级引用，>>+空格：表示二级引用

退出引用需要多按一次回车。

> 一级引用



> > 二级引用



>[danger]HTML,CSS,JavaScript是网友三剑客

>[success]success

>原色


### 4.列表

#### 4.1无序列表

使用*或者+或者-在跟上一个空格都可以(创建列表之后需要多回车一次才能退出列表)

- HTML
- CSS
- JavaScript


#### 4.2多行无序列表

\* 多行无序列表1

tab * 多行无序列表2

tab tab * 多行无序列表3

效果：

* 列表一
  * 列表二
    * 列表三



#### 4.3有序列表

1.有序列表1

2.有序列表2

3.有序列表3



### 5.代码块

#### 5.1单行代码

\`代码;\`	注意符号要是英文的。

`String str1="hello";`

#### 5.2多行代码

**(\~~~或```+回车键)**

~~~java
public class Student{
    
}
~~~



### 6.表格(快捷键ctrl+T)

![1564647093547](C:\Users\Administrator\AppData\Local\Temp\1564647093547.png)

|姓名|性别|年龄|手机号|
|:---|:--:|:--:|---:|
|张三|男|21|13520200012|
|李四|女|25|17723063415|
|王五|男|22|13020051234|



### 7.任务列表

\- \[ \] 文字 			(注：都要用空格隔开)

- [x] java

- [ ] C++

- [ ] pathon

### 8.特殊样式

> 下划线的效果是一对\<u\>把需要斜线的部分填在中间（快捷键是Ctrl+U）

<u>下划线</u>



> 加粗或者强调。粗体是一对双星号   \*\*加粗\*\*   （快捷键是Ctrl+b）

**strong**



> 斜体斜体是一对单星号*     \*斜体\*    （快捷键是Ctrl+i）

*斜体*



> 删除线，一对双波浪线\~\~删除\~\~（注意要在英文下输入）

~~删除线~~



> 居中。要居中的文字，用一对<center></center>表示，但是只能等到输出文本的时候才会看到效果

<center>居中显示</center>



> 脚注。脚注的正确用法：先创建一个，比如我要创建一个名字为“Typora”的脚注，那么我可以这样做，Typora[^ 2]（1可以换成任意字符，是用中括号，里面是个^然后空格（千万不要忘了空格））然后把鼠标放在2的上面他就会出现一个黑色的框框，点击，然后到最下面去编写，这样就完成了



> 下标。网上教程说用一对波浪线既可以表示，但是我没有试出来。后来又仔细的看了一下，可以了，需要右键insert打开Math Block，效果不是太好，比如水分子的表达式： 

H~2~O

砒霜As~2~O~3~



> 上标

跟下标差不多，也需要右键，用的操作符是^,比如 
x^2^



> 表情符号（两个冒号中间加上描述语，比如这个就是happy	\:happy\:）

:happy:



> 高亮显示：\=\=高亮显示内容\=\=(要在偏好设置中把设置打开)

==欢迎使用==



> 分割线。用三个”-“或者三个“*”连在一起即可

---

***



> 目录制作

在需要插入目录的地方写上[TOC]（大写小写都可以），回车，然后整篇文章的目录就自动形成了，比如最开始的那个目录就是通过这种方法生成的。



9.总结

    建议打开大纲视图（快捷键ctrl + shift + 1）。
    插入表格需要顶格写，不然显示不出来。
    以上语法不用刻意记，在Typora中的右键菜单都有， 常用功能基本上都有快捷键。



## 第二章 html总结

### 第一讲：html
#### 2.1.1介绍

- HTML 指的是超文本标记语言 (Hyper Text Markup Language)

		HTML 不是一种编程语言，而是一种标记语言 (markup language)   
	标记语言是一套标记标签 (markup tag)    HTML 使用标记标签来描述网页

#### 2.1.2标签

- HTML 标签是由尖括号包围的关键词，比如<html>
- HTML 标签通常是成对出现的(单个出现的叫自结束标签)，比如 <b>和</b>   标签对中的第一个标签是开始标签，第二个标签是结束标签   
- 开始和结束标签也被称为开放标签和闭合标签

meta标签用来设置网页的一些元数据，比如网页的字符集，关键字、简介。meta是一个自结束标签，编写一个自结束标签时，可以在开始标签中添加一个/。

<meta name="description" content="这是我写的一个酷炫的网站。">
<meta name="author" content="myname" />

使用meta标签还可以用来设置网页的关键字。
	<meta name="keywords" content="HTML5,JavaScript,前端,Java" />

还可以用来指定网页的描述，搜索引擎在检索页面时，会同时检索页面中的关键词和描述，但是这两个值不会影响页面在搜索引擎中的排名。
	<meta name="description" content="发布h5、js等前端相关的信息" />

使用meta可以用来做请求的重定向。
<meta http-equiv="refresh" content="秒数;url=目标路径" />
<meta http-equiv="refresh" content="5;url=http://www.baidu.com" />  5s后重定向到百度

#### 2.1.3.常用标签

1.HTML 标题（Heading）是通过 <h1>-<h6>等标签进行定义的。<h1>定义最大的标题<h6>定义最小的标签。

2.HTML 段落是通过<p>标签进行定义的。

3.HTML 链接是通过<a>标签进行定义的。

//注释：在 href 属性中指定链接的地址。

4 .HTML 图像是通过<img>标签进行定义的。
//注释：图像的名称和尺寸是以属性的形式提供的

5.大多数 HTML 元素可以嵌套（可以包含其他 HTML 元素）。

6.没有内容的 HTML 元素被称为空元素。空元素是在开始标签中关闭的。<br>就是没有关闭标签的空元素（<br>标签定义换行）。

7.标签内容最好都是小写。

8.HTML 标签可以拥有属性。属性提供了有关 HTML 元素的更多的信息。属性总是以名称/值对的形式出现，
比如：name="value"。属性总是在 HTML 元素的开始标签中规定。
属性值应该始终被包括在引号内。双引号是最常用的

9.<hr>标签在 HTML 页面中创建水平线。<hr> 元素可用于分隔内容。使用水平线 <hr>标签来分隔文章中的小节是一个办法（但并不是唯一的办法）。
10.可以将注释插入 HTML 代码中，这样可以提高其可读性，使代码更易被人理解。浏览器会忽略注释，也不会显示它们。

//注释：开始括号之后（左边的括号）需要紧跟一个叹号，结束括号之前（右边的括号）不需要。
提示：合理地使用注释可以对未来的代码编辑工作产生帮助。

11.超链接<a>标签的使用：
~~~html
	<!--
		1).跳到外部页面
        href里面写路径地址。target属性表示打开方式，具体如下
        _self:自身窗口打开 _blank:新窗口打开 _top:跳到当前页面顶部
        	
        2).打开本地资源，如前面已经写好的页面
        href里面写路径，也满足相对，绝对路径原则
        	
        3).找到一个锚点
        	如何使用：
        	@1,给一个标签设置id属性，那么这个这个标签就可以作为一个锚点
        	@2,使用<a href="#锚点的id值">..</a>
        	@  单独一个"#"表示调到当前页面顶部，与_top相同
        		
        4).还可以发邮件，打电话（用于移动端）,QQ
        	href里面写mailto:邮件地址
        	tel:电话号码
        5).找到超链接，用text-decortion可去掉下划线
    -->
~~~
12.name 属性规定锚（anchor）的名称。您可以使用 name 属性创建 HTML 页面中的书签。书签不会以任何特殊方式显示，它对读者是不可见的。
当使用命名锚（named anchors）时，我们可以创建直接跳至该命名锚（比如页面中某个小节）的链接，这样使用者就无需不停地滚动页面来寻找他们需要的信息了。
提示：锚的名称可以是任何你喜欢的名字。
提示：您可以使用 id 属性来替代 name 属性，命名锚同样有效。

13.图像标签<img>：
使用img标签来向网页中引入一个外部图片。img标签也是一个自结束标签。
属性：
src：设置一个外部图片的路径。
alt：可以用来设置在图片不能显示时，对图片的描述。搜索引擎可以通过alt属性来识别不同的图片。如果不写alt属性，则搜索引擎不会对img中的图片进行收录。

title:当鼠标移动到图片上显示的内容。
width：可以用来修改图片的宽度,一般使用px作为单位。
height：可以用来修改图片的高度，一般使用px作为单位。
宽度和高度两个属性如果指设置一个，另一个也会同时等比例调整大小如果两个值同时指定则按照你指定的值来设置，一般开发中除了自适应的页面(根据设备不同，显示效果不一样)，不建议设置width和height。	
		src属性配置的是图片的路径，目前我们所要使用的路径全都是相对路径。
相对路径：相对路径指相对于当前资源所在目录的位置，可以使用../来返回一级目录,返回几级目录就写几个../
<img src="abc/bcd/2.gif" alt="这是一个大松鼠"/>

<img src="../../img/2.gif" alt="这是一个大松鼠"/>

14.特殊字符：
在HTML中，一些如< >这种特殊字符是不能直接使用，需要使用一些特殊的符号来表示这些特殊字符，这些特殊符号我们称为实体（转义字符串）。浏览器解析到实体时，会自动将实体转换为其对应的字符
实体的语法：&实体的名字;
<  &lt;         >  &gt;      空格  &nbsp;      版权符号 &copy;         &divide;  ÷

15.表格由<table> 标签定义。每行被分割为若干单元格（由 <tr> 标签定义）。字母 <td> 指表格数据（table data），即数据单元格的内容。
数据单元格可以包含文本、图片、列表、段落、表单、水平线、表格等等。表格的表头使用<th>标签进行定义。

16.无序列表是一个项目的列表，此列项目使用粗体圆点（典型的小黑圆圈）进行标记。无序列表始于<ul>标签。每个列表项始于<li>标签。

17.有序列表也是一列项目，列表项目使用数字进行标记。有序列表始于<ol>标签。每个列表项始于<li>标签。

18.自定义列表不仅仅是一列项目，而是项目及其注释的组合。自定义列表以<dl>标签开始。每个自定义列表项以<dt>开始。每个自定义列表项的定义以<dd>开始。
19.块状元素：<h1>-<h6>  <p>  <ul>  <table>  <li>  行类元素：<b>   <td>   <a>  <img>

20.背景颜色属性将背景设置为某种颜色。属性值可以是十六进制数、RGB(255,255,255)值(0-255)或颜色名。

#### 2.1.4.图片的格式

- JPEG(JPG)- JPEG图片支持的颜色比较多，图片可以压缩，但是不支持透明，一般使用JPEG来保存照片等颜色丰富的图片。
- GIF- GIF支持的颜色少，只支持简单的透明，支持动态图，图片颜色单一或者是动态图时可以使用gif。
- PNG- PNG支持的颜色多，并且支持复杂的透明，可以用来显示颜色复杂的透明的图片。

> 图片的使用原则：效果不一致，使用效果好的。效果一致，使用小的。
> 编写一段内容，在纯文本编辑器中编写的内容都是纯文本，网页就是使用纯文本编写的。纯文本中只能保持文本内容。图片，音频，视频等格式化的内容，都不能设置。



==元素的自定义属性：在HTML中能自定义属性的只有如下：id（不允许重复）、 class、 name（可重复）==

### 第二讲：CSS

#### 2.2.1CSS样式

1. CSS:层叠样式表

为了修饰html中的元素的样子
css注释： /* css注释 */

2. 内联样式（行内样式） 

<p style="color:red;">..</p>    缺点：表现跟结构耦合。

可以将CSS样式编写到元素的style属性当中。将样式直接编写到style属性中，这种样式我们称为内联样式。内联样式只对当前的元素中的内容起作用，
内联样式不方便复用。内联样式属于结构与表现耦合，不方便后期的维护，不推荐使用。

3. 内部样式表。

选择器+声明块. 在head标签之中写。  缺点：代码复用性不好。

将CSS样式编写到head中的style标签里。将样式表编写的style标签中，然后通过CSS选择器选中指定元素。然后可以同时为这些元素一起设置样式，
这样可以使样式进一步的复用。将样式表编写到style标签中，也可以使表现和结构进一步分离它也是我们推荐的使用方式。

```html
ps:字体悬停变蓝，鼠标手势变化

<style type="text/css">

		p:hover{
		color:blue;//颜色变化
		cursor:pointer;//鼠标变化
		text-decoration://文字变化
		}

</style>
```

4. 外部样式表。

创建一个css文件，需要用时在通过<link rel="stylesheet" type="text/css" href=".." />引用

可以将样式表编写到外部的CSS文件中,然后通过link标签来将外部的CSS文件引入到当前页面中，这样外部文件中的css样式表将会应用到当前页面中。
将CSS样式统一编写到外部的样式表中，完全使结构和表现分离，可以是样式表可以在不同的页面中使用，最大限度的使样式可以进行复用，
将样式统一写在样式表中，然后通过link标签引入，可以利用浏览器的缓存加快用户访问的速度提高了用户体验，所以在开发中我们最推荐使用的方式就是外部的CSS文件。

优点：可以将表现跟结构分离，完成了解耦。实现了复用性。
可以利用浏览器缓存，提高页面的加载速度。
引入：<link rel="stylesheet" type="text/css" href="css/demo.css"/>
	
>[danger] 优先级：行内样式>内部样式>外部样式。	

5. 样式的选择

> [success]当样式需要被应用到很多页面的时候，外部样式表将是理想的选择。使用外部样式表，你就可以通过更改一个文件来改变整个站点的外观。

&gt;[success]当样式需要被应用到很多页面的时候，外部样式表将是理想的选择。使用外部样式表，你就可以通过更改一个文件来改变整个站点的外观。

> [success]当单个文件需要特别样式时，就可以使用内部样式表。你可以在head部分通过<style>标签定义内部样式表。

> [success]当特殊的样式需要应用到个别元素时，就可以使用内联样式。 使用内联样式的方法是在相关的标签中使用样式属性。样式属性可以包含任何 CSS 属性。

&gt;[success]当特殊的样式需要应用到个别元素时，就可以使用内联样式。 使用内联样式的方法是在相关的标签中使用样式属性。样式属性可以包含任何 CSS 属性。

样式重置

- 部分标签自带预设样式需要重置

// &#039;*&#039;代表所有标签
*{margin:0;boder:0;padding:0;}

ps:写样式为了更方便设置，一定要重置

- 块水平居中

> margin-left:auto;
> margin-right:auto;
> //仅对块元素有效
>
>
> body{
>     text-align:center;
> }  //给内联和内联块的父元素加入该代码（此处其父元素为body）
>

#### 2.2.2选择器
- 元素选择器

1.*{} 通配符，匹配所有元素
2.直接写元素名称
3.id选择器  #id值{}   只能找到一个唯一的元素
4.类别选择器  .class值{}  可能会找到多个元素。

- 关系选择器

1.center p{}  center中的所有p标签(直接、间接子元素)
2.center>p{} 找到直接子元素
3.center+p{}  找到紧贴在center后的p元素。
4.center~p{}  找到center后面的所有兄弟元素p。

- 属性选择器

1.a[class]{}    有class属性的a标签
2.a[class="val"]{}
3.a[class~="val"]{}   class的值中包含val即可	class可有多个属性值，属性值之间用空格分隔。
4.a[class^="val"]{}   属性值以val开头
5.a[class$="val"]{}   属性值以val结尾
6.a[class*="val"]{}  属性值包含val。
7.a[class|="val"]{}	属性值以val开头，属性值以-分隔，如val-xss。

- 伪类选择器：

伪类：专门用来表示元素的特殊状态。
    超链接：
	a:link：未被访问时的样式。
	a:visited 
	a:hover 鼠标悬停时的样式
	a:active  设置元素在被用户激活（在鼠标点击与释放之间发生的事件）时的样式。 
>[danger]		hover、active可以为其它元素使用。但hove放在active前。

E:focus：对象在成为输入焦点（该对象的onfocus事件发生）时的样式。
input:focus{background-color: yellow;}
E:lang()：匹配使用特殊语言的E元素。p:lang(zh-cn){color:#f00;}
E:not()：匹配不含有s选择符的元素E。p:not(.abc){color:#f00;}
E:root：匹配E元素在文档的根元素。在HTML中，根元素永远是HTML 。
E:first-chlild：匹配父元素的第一个子元素E
E:last-child
E:only-child：匹配父元素仅有的一个子元素E
E:nth-child(n)匹配父元素的第n个子元素E   odd奇数个   even偶数个 数字：从1开始
E:nth-last-child(n)
E:first-of-type：匹配同类型中的第一个同级兄弟元素E
E:last-of-type
E:only-of-type
E:nth-of-type(n)匹配同类型中的第n个同级兄弟元素E
E:nth-last-of-type(n)
E:empty  匹配没有任何子元素（包括text节点）的元素E。
空:<p></p>    <p<!--fgffgf--></p>         非空: <p>   </p>

E:checked：匹配用户界面上处于选中状态的元素E。(用于input type为radio与checkbox时)。
元素的checked属性
E:enabled：匹配用户界面上处于可用状态的元素E
E:disabled：匹配用户界面上处于禁用状态的元素E。		元素的disable属性：是否禁用。

- 伪对象选择器：来表示元素中的一些特殊的位置。

E：first-letter/E::first-letter设置对象内的第一个字符的样式。 
此伪对象仅作用于块对象。内联对象要使用该伪对象，必须先将其设置为块级对象。 该伪类常被用来配合font-size属性和float属性制作首字下沉效果
E：first-line/E::first-line
设置对象内的第一行的样式。此伪对象仅作用于块对象。内联对象要使用该伪对象，必须先将其设置为块级对象。
E：before/E::before设置在对象前（依据对象树的逻辑结构）发生的内容。用来和content属性一起使用 
E：after/E::after
E::selection设置对象被选择时的样式。如文字选中时背景颜色变化。注意：这个伪类在火狐中需要采用另一种方式编写::-moz-selection

- 样式的继承：

像儿子可以继承父亲的遗产一样，在CSS中，祖先元素上的样式，也会被他的后代元素所继承,利用继承，可以将一些基本的样式设置给祖先元素，
这样所有的后代元素将会自动继承这些样式。但是并不是所有的样式都会被子元素所继承，比如：背景相关的样式都不会被继承 边框相关的样式 定位相关的。
style type="text/css">
			body{
				font-size: 30px;
			}
		</style>

- 选择器优先级：

当使用不同的选择器，选中同一个元素时并且设置相同的样式时，这时样式之间产生了冲突，最终到底采用哪个选择器定义的样式，由选择器的优先级（权重）决定。优先级高的优先显示。
		优先级的规则
			 内联样式 ， 优先级  1000
			 id选择器，优先级   500
			 类和伪类， 优先级  100
			 元素选择器，优先级 10 
			 通配* ，    优先级 1
			 继承的样式，没有优先级
			 
	当选择器中包含多种选择器时，需要将多种选择器的优先级相加然后在比较，但是注意，选择器优先级计算不会超过他的最大的数量级，如果选择器的优先级一样，则使用靠后的样式。
	并集选择器的优先级是单独计算  div , p , #p1 , .hello{}	

#### 2.2.3表单input
**1.属性**：type：hidden、password、text、radio、file、checkbox、radio(默认选中checked)

button普通按钮，不触发js时无任何作用。

重置reset
submit提交按钮(可通过value属性指定按钮上的文字)
Color、number、date、search...

Maxlength/size单位为字符  
readonly="readnly"  
disabled    
placeholder占位符

type为radio/checkbox：像这种需要用户选择但是不需要用户直接填写内容的表单项，还必须指定一个value属性，这样被选中的表单项的value属性值将会最终提交给服务器。

在表单中可以使用fieldset来为表单项进行分组，可以将表单项中的同一组放到一个fieldset中
~~~html
	<fieldset>
	
				<!-- 在fieldset可以使用legend子标签，来指定组名 -->
				<legend>用户信息</legend>
				<!-- 
					用户填写的信息会附在url地址的后边以查询字符串的形式发送给服务器
						url地址?查询字符串
					格式：
						属性名=属性值&属性名=属性值&属性名=属性值&属性名=属性值
					在文本框中也可以指定value属性值，该值将会作为文本框的默认值显示	
				-->
				<!-- 
					在html中还为我们提供了一个标签，专门用来选中表单中的提示文字的
					label标签
					该标签可以指定一个for属性，该属性的值需要指定一个表单项的id值
				-->
				<label for="um">用户名</label>
				<input id="um" type="text" name="username" placeholder="请输入用户名..." size="" maxlength="15" /> <br /><br />
				
				<!--
					密码框
						- 使用input创建一个密码框，它的type属性值是password
				-->
				<label for="pwd">密码 </label>
				<input id="pwd" type="password" name="password" /> <br /><br />
			</fieldset>
~~~

**2.textarea**
使用textarea创建一个文本域
		自我介绍  <textarea name="info"></textarea>
		
3.select(指定name属性)：子元素option(value属性) ：seleced默认选中。
属性：muliple  属性规定可同时选择多个选项。
在不同操作系统中，选择多个选项的差异：
	对于 windows：按住 Ctrl 按钮来选择多个选项
	对于 Mac：按住 command 按钮来选择多个选项
由于上述差异的存在，同时由于需要告知用户可以使用多项选择，对用户更友好的方式是使用复选框。
提示：可以把 multiple 属性与 size 属性配合使用，来定义可见选项的数目。
~~~html
<select name="star">
					<!-- 
						在select中可以使用optgroup对选项进行分组
							同一个optgroup中的选项是一组
						可以通过label属性来指定分组的名字	
					-->
					<optgroup label="女明星">
						<!-- 在下拉列表中使用option标签来创建一个一个列表项 -->
						<option value="fbb">范冰冰</option>
						<option value="lxr">林心如</option>
						<option value="zw">赵薇</option>
					</optgroup>
					
					<optgroup label="男明星">
						<option value="zbs" selected="selected">赵本山</option>
						<option value="ldh">刘德华</option>
						<option value="pcj">潘长江</option>
					</optgroup>
				</select>
				
				<!--
				除了使用input，也可以使用button标签来创建按钮
				这种方式和使用input类似，只不过由于它是成对出现的标签
				使用起来更加的灵活
			-->
			<button type="submit">提交</button>
			<button type="reset">重置</button>
			<button type="button">按钮</button>
~~~



**3.单位：**

- 长度单位：像素 px
	*像素是我们在网页中使用的最多的一个单位，一个像素就相当于我们屏幕中的一个小点，我们的屏幕实际上就是由这些像素点构成的，但是这些像素点，是不能直接看见。
	*不同显示器一个像素的大小也不相同，显示效果越好越清晰，像素就越小，反之像素越大。
	
- 百分比 %:
	- 也可以将单位设置为一个百分比的形式，这样浏览器将会根据其父元素的样式来计算该值。
- 使用百分比的好处是，当父元素的属性值发生变化时，子元素也会按照比例发生改变。
	- 在我们创建一个自适应的页面时，经常使用百分比作为单位。

- em:
	- em和百分比类似，它是相对于当前元素的字体大小来计算的。
	- 1em = 1font-size
	- 使用em时，当字体大小发生改变时，em也会随之改变。
	- 当设置字体相关的样式时，经常会使用em。

**4.font**：

在CSS中还为我们提供了一个样式叫font，使用该样式可以同时设置字体相关的所有样式,可以将字体的样式的值，统一写在font样式中，不同的值之间使用空格隔开。使用font设置字体样式时，斜体 加粗 小大字母，没有顺序要求，甚至可写可不写，如果不写则使用默认值，但是要求文字的大小和字体必须写，而且字体必须是最后一个样式，大小必须是倒数第二个样式。实际上使用简写属性也会有一个比较好的性能。

`P{	font: small-caps bold italic 60px "微软雅黑";	}`

在font中也可以指定行高,在**字体大小后可以添加** **/行高**，来指定行高，该值是可选的，如果不指定则会使用默认值.

~~~html
.p2 {
                /*font: 30px "微软雅黑";
                line-height: 50px;*/
                font:30px/50px "微软雅黑";
            }
~~~

**5.line-height来设置行高**

在CSS并没有为我们提供一个直接设置行间距的方式，我们只能通过设置行高来间接的设置行间距，行高越大行间距越大,使用line-height来设置行高,行高类似于我们上学单线本，单线本是一行一行，线与线之间的距离就是行高，网页中的文字实际上也是写在一个看不见的线中的，而文字会默认在行高中垂直居中显示.行间距 = 行高 - 字体大小。

对于**单行文本**来说，可以将行高设置为和父元素的高度一致，这样可以是单行文本在父元素中垂直居中。

~~~html
.p1{
				font-size: 20px;
				/*
				 * 通过设置line-height可以间接的设置行高，
				 * 	可以接收的值：
				 * 		1.直接就收一个大小
				 * 		2.可以指定一个百分数，则会相对于字体去计算行高
				 * 		3.可以直接传一个数值，则行高会设置字体大小相应的倍数
				 */
				/*line-height: 200%;*/
				
				line-height: 2;
			}
~~~



#### 2.2.4盒子模型

- div用于页面布局,是块级元素，独占一行

  相当于一个容器，如果你的内容超过容器所给的大小，装不下，就会有部分内容涌出容器外

				 用*{margin:0; padding:0;}可以清除浏览器默认的样式			
		
				 padding 内边距，内容距离边框的大小
			 margin 外边距，div盒子与页面的距离

==居中：margin:0px; auto==

			/*
			关于div不能居中的问题：
			 1、没有设置宽度 看看上面的代码，如果没有设置DIV的宽度，
			 如何根据宽度自适应呢？新手比较容易忽略的问题。 
			 2、没声明DOCTYPE 
			 DOCTYPE是document type（文档类型）的简写，
			 在web设计中用来说明你用的XHTML或者HTML是什么版本。
			 要建立符合标准的网页，DOCTYPE声明是必不可少的关键组成部分。
			 * */
- 边框(border)

  border可以指定四个数，分别表示边框的上、右、下、左
  		写一个数，表示上右下左
  		写两个，表示上下，左右
  		写三个，表示上，左右，下*/

  > border-width:20px 40px;
  >
  > border-color: #008000;
  >
  > border-style: solid;

  border的三个属性，可以分开设置，也可以像下面这样合并设置，但必须是三个属性都有(宽度，颜色，类型)

  > border-left:20px #FF6600 solid;



- **内联元素盒子**
  - 内联元素不能设置width和height。
  - 内联元素可以设置水平方向的内边距。垂直方向内边距，内联元素可以设置垂直方向内边距，但是不会影响页面的布局。
  	 为元素设置边框,	内联元素可以设置边框，但是垂直的边框不会影响到页面的布局。
  - 水平外边距，内联元素支持水平方向的外边距。内联元素不支持垂直外边距。

为右边的元素设置一个左外边距，水平方向的相邻外边距不会重叠，而是求和。



+ **Display**:

  将一个内联元素变成块元素，通过display样式可以修改元素的类型。

  + 可选值：
    + inline：可以将一个元素作为内联元素显示
    + block: 可以将一个元素设置块元素显示
    + inline-block：将一个元素转换为行内块元素，可以使一个元素既有行内元素的特点又有块元素的特点，既可以设置宽高，又不会独占一行。
    + none: 不显示元素，并且元素不会在页面中继续占有位置。



- **visibility**	

  可以用来设置元素的隐藏和显示的状态

  - 可选值：

  - visible 默认值，元素默认会在页面显示。

     hidden 元素会隐藏不显示。	

  - > 使用 visibility:hidden;隐藏的元素虽然不会在页面中显示，但是它的位置会依然保持。



- **Overflow**:

  子元素默认是存在于父元素的内容区中，理论上讲子元素的最大可以等于父元素内容区大小，如果子元素的大小超过了父元素的内容区，则超过的大小会在父元素以外的位置显示，超出父元素的内容，我们称为溢出的内容，父元素默认是将溢出内容，在父元素外边显示，通过overflow可以设置父元素如何处理溢出内容：

  可选值：

  - visible，默认值，不会对溢出内容做处理，元素会在父元素以外的位置显示
  - hidden, 溢出的内容，会被修剪，不会显示
  - scroll, 会为父元素添加滚动条，通过拖动滚动条来查看完整内容
  - 该属性不论内容是否溢出，都会添加水平和垂直双方向的滚动条
  - auto，会根据需求自动添加滚动条，需要水平就添加水平,需要垂直就添加垂直,都不需要就都不加。



- 背景图片

  Background属性:

  - background-color

  - background-position:Xpx; Ypx;  距左X，距上Y

  - background-size:背景图片大小

  - > 1.background-size: 200px 200px;  通过像素设置 
    >
    > 2.background-size: 50% 50%;    通过百分比设置
    >
    > 3.background-size: cover;  覆盖:图片成比例填满盒子。可用于适配
    >
    > 4.background-size: contain; 包含:图片成比例放大,可能不会填满盒子。可用于适配 

  - background-repeat:Repeat-x  、repeat-y 、no-repeat、 repeat（默认）

  - inherit（从父元素继承 background-repeat 属性的设置）、

  - background-image:url(../img/index.jpg)

  也可以合成一个background，如下

  `.title{background: url(../day3/image/icon_03.gif) 0px 2px no-repeat;}`

```
常用块元素：div  	    dl – 定义列表 		form – 交互表单 	h1 – h6 标题 
hr – 水平分隔线 		menu – 菜单列表 	 ol – 有序表单 	 	 p – 段落 
pre – 格式化文本 	table – 表格 		   ul – (li)无序列表 	

常用内联元素有：1.<span>	2.<b>	3.<img>		4.input		5.<a>
```



#### 2.2.5浮动

**1.什么是文档流**

文档流：指书写在html文件中的代码，浏览器解析的时候，会按照什么样的规律进行排版。

文档流处在网页的最底层，它表示的是一个页面中的位置，我们所创建的元素默认都处在文档流中，元素在文档流中的特点：

- 块元素
  - 1.块元素在文档流中会独占一行，块元素会自上向下排列。
  - 2.块元素在文档流中默认宽度是父元素的100%
  - 3.块元素在文档流中的高度默认被内容撑开
- 内联元素
  - 1.内联元素在文档流中只占自身的大小，会默认从左向右排列，如果一行中不足以容纳所有的内联元素，则换到下一行，继续自左向右。
  	 2.在文档流中，内联元素的宽度和高度默认都被内容撑开。	

*当元素的宽度的值为auto时，此时指定内边距不会影响可见框的大小，而是会自动修改宽度，以适应内边距。*



**2.浮动：**

块元素在文档流中默认垂直排列，所以这个三个div自上至下依次排开，如果希望块元素在页面中水平排列，可以使块元素脱离文档流

使用float来使元素浮动，从而脱离文档流

可选值：

- none，默认值，元素默认在文档流中排列
- left，元素会立即脱离文档流，向页面的左侧浮动
	 right，元素会立即脱离文档流，向页面的右侧浮动				 

​        当为一个元素设置浮动以后（float属性是一个非none的值），元素会立即脱离文档流，元素脱离文档流以后，它下边的元素会立即向上移动；元素浮动以后，会尽量向页面的左上或这是右上漂浮，<u>直到遇到父元素的边框或者其他的浮动元素</u>；如果浮动元素上边是一个没有浮动的块元素，则浮动元素不会超过块元素；浮动的元素不会超过他上边的兄弟元素，最多最多一边齐。

**浮动的元素不会盖住文字**，文字会自动环绕在浮动元素的周围，所以我们可以通过浮动来设置文字环绕图片的效果。

在文档流中，子元素的宽度默认占父元素的全部；当元素设置浮动以后，会完全脱离文档流.块元素脱离文档流以后，高度和宽度都被内容撑开；

~~~html
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
		<style type="text/css">	
			.box1{
				/*float: left;*/
			}
			
			.s1{
				/*开启span的浮动
				 *内联元素脱离文档流以后会变成块元素
				 */
				float: left;
				width: 100px;
				height: 100px;
				background-color: yellow;
			}
		</style>
	</head>
	<body>
		<div class="box1">a</div>
		<span class="s1">hello</span>
        <span class="s2">第二个span，没有开启浮动，如果开启了浮动，他也会变为块元素，跑到第一个span的下面</span>
		<p>test float</p>
	</body>
</html>
~~~

![1564800357411](C:\Users\Administrator\AppData\Local\Temp\1564800357411.png)

> 从上图也可以看到，浮动的元素不会盖住文字，文字会自动环绕在浮动元素的周围，所以我们可以通过浮动来设置文字环绕图片的效果



#### 2.2.6高度塌陷

**概念**：在文档流中，父元素的高度默认是被子元素撑开的，也就是子元素多高，父元素就多高。但是当为子元素设置浮动以后，子元素会完全脱离文档流，此时将会导致子元素无法撑起父元素的高度，导致父元素的高度塌陷。由于父元素的高度塌陷了，则父元素下的所有元素都会向上移动，这样将会导致页面布局混乱。所以在开发中一定要避免出现高度塌陷的问题,我们可以将父元素的高度写死，以避免塌陷的问题出现，但是一旦高度写死，父元素的高度将不能自动适应子元素的高度，所以这种方案是不推荐使用的。

~~~HTML
<head>
		<meta charset="utf-8" />
		<title>高度塌陷</title>
		<style type="text/css">			
			.box1{
				/*为box1设置一个边框*/
				border: 10px red solid;			
			}
			
			.box2{
				width: 100px;
				height: 100px;
				background-color: blue;
			
				/*为子元素设置向左浮动*/
				float: left;
			}
			
			.box3{
				 height: 100px;
				 background-color: yellow;
			}			
		</style>
	</head>
	<body>		
		<div class="box1">
			<div class="box2"></div>
		</div>
		
		<div class="box3"></div>		
	</body>
~~~

![1564801215342](C:\Users\Administrator\AppData\Local\Temp\1564801215342.png)

> 如图box1为红色部分，box2为蓝色部分，box3为黄色部分。box2没有浮动之前，box1应该包裹住box2，然后box3作为box1的兄弟元素位于box1的正下方。但是由于box2的浮动，box1不能被撑起来，下方元素box3也跑了上来，box2直接“穿透”box1，造成高度塌陷，页面混乱。



#### 2.2.7解决高度塌陷

**1.BFC解决高度塌陷**

- BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于定位方案的普通流。

- 根据W3C的标准，在页面中元素都一个隐含的属性叫做Block Formatting Context

  简称BFC，该属性可以设置打开或者关闭，默认是关闭的。当开启元素的BFC以后，元素将会具有如下的特性：

  - 父元素的垂直外边距不会和子元素重叠	
  - 2.开启BFC的元素不会被浮动元素所覆盖
  - 3.开启BFC的元素可以包含浮动的子元素

具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。

通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。

- 如何开启元素的BFC:

  BFC：<https://blog.csdn.net/qiphon3650/article/details/79427334>

  - (1).设置元素浮动。使用这种方式开启，虽然可以撑开父元素，但是会导致父元素的宽度丢失，而且使用这种方式也会导致下边的元素上移，不能解决问题
  - (2).设置元素绝对定位
  - (3).设置元素为inline-block - 可以解决问题，但是会导致宽度丢失，不推荐使用这种方式。
  - (4).将元素的overflow设置为一个非visible的值。

		荐方式：将overflow设置为hidden是副作用最小的开启BFC的方式。	 

> 但是在IE6及以下的浏览器中并不支持BFC，所以使用这种方式不能兼容IE6。
>
> 在IE6中虽然没有BFC，但是具有另一个隐含的属性叫做hasLayout，该属性的作用和BFC类似，所在IE6浏览器可以通过开hasLayout来解决该问题。
>
> 开启方式很多，我们直接使用一种副作用最小的： 直接将元素的zoom设置为1即可。zoom表示放大的意思，后边跟着一个数值，写几就将元素放大几倍，zoom:1表示不放大元素，但是通过该样式可以开启hasLayout，zoom这个样式，只在IE中支持，其他浏览器都不支持。

- 还是上面高度塌陷的例子，用BFC解决如下

~~~html
	<head>
		<meta charset="utf-8" />
		<title>BFC</title>
		<style type="text/css">
			
			.box1{
				border: 10px red solid;
			
				zoom:1;
				overflow: hidden;	
			}
			
			.box2{
				width: 100px;
				height: 100px;
				background-color: blue;
				float: left;				
			}
			
			.box3{
				 height: 100px;
				 background-color: yellow;
			}
			
		</style>
	</head>
	<body>	
		<div class="box1">
			<div class="box2"></div>
		</div>
		
		<div class="box3"></div>		
	</body>
~~~

![1564803445008](C:\Users\Administrator\AppData\Local\Temp\1564803445008.png)

**2.解决方案二**

​        可以直接在高度塌陷的父元素的最后，添加一个空白的div，由于这个div并没有浮动，所以他是可以撑开父元素的高度的，然后在对其进行清除浮动，这样可以通过这个空白的div来撑开父元素的高度，基本没有副作用。
使用这种方式虽然可以解决问题，但是会在页面中添加多余的结构。

~~~html
	<head>
		<meta charset="UTF-8">
		<title></title>
		<style type="text/css">
			.box1{
				border: 1px solid red;
			}
			
			.box2{
				width: 100px;
				height: 100px;
				background-color: blue;
				
				float: left;
			}
			.clear{
				clear: both;
			}
			
		</style>
	</head>
	<body>
		<div class="box1">
			<div class="box2"></div>
			<div class="clear"></div>
		</div>
	</body>
~~~

**3.解决方案三**

​        可以通过after伪类向元素的最后添加一个空白的块元素，然后对其清除浮动，这样做和添加一个div的原理一样，可以达到一个相同的效果，而且不会在页面中添加多余的div，这是我们最推荐使用的方式，几乎没有副作用。

~~~html
	<head>
		<meta charset="UTF-8">
		<title></title>
		<style type="text/css">
			
			.box1{
				border: 1px solid red;
			}
			
			.box2{
				width: 100px;
				height: 100px;
				background-color: blue;
				
				float: left;
			}
			.clearfix:after{
				/*添加一个内容*/
				content: "";
				/*转换为一个块元素*/
				display: block;
				/*清除两侧的浮动*/
				clear: both;
			}
			
			/*
			 * 在IE6中不支持after伪类,
			 * 	所以在IE6中还需要使用hasLayout来处理
			 */
			.clearfix{
				zoom:1;
			}	
		</style>
	</head>
	<body>
		<div class="box1 clearfix"> <!--class属性设置多个值-->
			<div class="box2"></div>
		</div>
	</body>
~~~

**4.终极解决方案**

​	子元素和父元素相邻的垂直外边距会发生重叠，子元素的外边距会传递给父元素，使用空的table标签可以隔离父子元素的外边距，阻止外边距的重叠。

- 经过修改后的clearfix是一个多功能的，既可以解决高度塌陷，又可以确保父元素和子元素的垂直外边距不会重叠

~~~html
 		 .clearfix:before,
		 .clearfix:after{
		 	content:"";
		 	display:table;
		 	clear:both;
		 }

		 .clearfix{
			zoom: 1;
		}
~~~

​		

#### 2.2.8定位

定位：指的就是将指定的元素摆放到页面的任意位置，通过定位可以任意的摆放元素

通过position属性来设置元素的定位

可选值：

- static：默认值，元素没有开启定位
- relative：开启元素的相对定位
- absolute：开启元素的绝对定位
- fixed：开启元素的固定定位（也是绝对定位的一种）



**1.相对定位**

- 当元素的position属性设置为relative时，则开启了元素的相对定位。
   - (1).当开启了元素的相对定位以后，而不设置偏移量时，元素不会发生任何变化
  - (2).相对定位是相对于元素在文档流中原来的位置进行定位
  - (3).相对定位的元素不会脱离文档流
  - (4).相对定位会使元素提升一个层级
  - (5).相对定位不会改变元素的性质，块还是块，内联还是内联

 

- 当开启了元素的定位（position属性值是一个非static的值）时，可以通过left right top bottom四个属性来设置元素的偏移量。

  - left：元素相对于其定位位置的左侧偏移量
  - right：元素相对于其定位位置的右侧偏移量
  - top：元素相对于其定位位置的上边的偏移量
  - bottom：元素相对于其定位位置下边的偏移量

  通常偏移量只需要使用两个就可以对一个元素进行定位，一般选择水平方向的一个偏移量和垂直方向的偏移量来为一个元素进行定位。

**2.绝对定位**

- 当position属性值设置为absolute时，则开启了元素的绝对定位。				 
  - (1).开启绝对定位，会使元素脱离文档流
  - (2).开启绝对定位以后，如果不设置偏移量，则元素的位置不会发生变化
  - (3)**.绝对定位是相对于离他最近的开启了定位的祖先元素进行定位的（一般情况，开启了子元素的绝对定位都会同时开启父元素的相对定位）如果所有的祖先元素都没有开启定位，则会相对于浏览器窗口进行定位。**
  - (4).绝对定位会使元素提升一个层级
  - (5).绝对定位会改变元素的性质，内联元素变成块元素，块元素的宽度和高度默认都被内容撑开

**3.固定定位**

​	当元素的position属性设置fixed时，则开启了元素的固定定位，固定定位也是一种绝对定位，它的大部分特点都和绝对定位一样。

​	不同的是：**固定定位永远都会相对于浏览器窗口进行定位**；**固定定位会固定在浏览器窗口某个位置，不会随滚动条滚动**；IE6不支持固定定位。

`如果定位元素的层级是一样，则下边的元素会盖住上边的(body中后写的盖住先写的)。`

通过z-index改变元素层级时：可以为z-index指定一个正整数作为值，该值将会作为当前元素的层级，层级高的元素优先显示，可能会覆盖层级低的但是，<u>父元素即使层级再高也不会覆盖子元素</u>。默认情况下：子元素会覆盖父元素，同级的后面的元素会覆盖前面的元素



**4.透明度**

opacity可以用来设置元素背景的透明，它需要一个0-1之间的值

- 0 表示完全透明
- 1 表示完全不透明
- 0.5 表示半透明

`opacity: 0.5;`

opacity属性在IE8及以下的浏览器中不支持，IE8及以下的浏览器需要使用如下属性代替			

	/*alpha(opacity=透明度)，需要一个0-100之间的值
		0 表示完全透明
		100 表示完全不透明
		50 半透明
		这种方式支持IE6，但是这种效果在IE Tester中无法测试*/
	filter: alpha(opacity=50);


#### 2.2.9框架集frameset

- 框架集和内联框架的作用类似，都是用于在一个页面中引入其他的外部的页面，框架集可以同时引入多个页面，而内联框架只能引入一个，在h5标准中，推荐使用框架集，而不使用内联框架。

		使用frameset来创建一个框架集，注意frameset不能和body出现在同一个页面中，所以要使用框架集，页面中就不可以使用body标签。

		属性：
		
			rows，指定框架集中的所有的框架，一行一行的排列
		
			cols， 指定框架集中的所有的页面，一列一列的排列
		
		这两个属性frameset必须选择一个，并且需要在属性中指定每一部分所占的大小
		
		frameset中也可以再嵌套frameset			

	 frameset和iframe一样，它里边的**内容都不会被搜索引擎所检索**，所以如果搜索引擎检索到的页面是一个框架页的话，它是不能去判断里边的内容的；使用框架集则意味着页面中不能有自己的内容，只能引入其他的页面，而我们每单独加载一个页面，浏览器都需要重新发送一次请求，引入几个页面就需要发送几次请求，用户的体验比较差；如果非得用，建议使用frameset而不使用iframe	





## 第三章 JavaScript

### 3.1 JS概述

- JavaScript是一种脚本语言，主要用于提高网页的互动性

- JavaScript运行在用户的终端网页上，而不是服务器上，所以我们称为“前台语言”
- JavaScript就是一个简单的制作页面效果的语言，就是服务于页面的交互效果、美化、绚丽，不能操作数据库。

**1.JavaScript的组成**

> JavaScript基础分为三个部分：
>
> ECMAScript: JavaScript的语法标准。包括变量、表达式、运算符、函数、if语句、for语句等。
>
> &gt;ECMAScript: JavaScript的语法标准。包括变量、表达式、运算符、函数、if语句、for语句等。
> DOM：操作网页上元素的API。比如让盒子移动、变色、轮播等。
> BOM：操作浏览器部分功能的API，比如上浏览器自动滚动。
>

**2.JavaScript用法**

~~~
HTML中的脚本必须位于<script>与</script>标签之间。
脚本可被放置在HTML页面的<body>和<head>部分中。
脚本推荐放在最下边：防止因网络问题，页面加载时间长，出现空白；即便网络问题，浏览器也把DOM加载渲染完成，等待从服务端下载完js脚本，出现效果
~~~

**js输出提示（弹窗、写到页面body里面、写到控制台输出日志）**

- 弹出警告框：alert（&quot;&quot;）

~~~html
 <script type="text/javascrip>
            alert("你点我了。。。");
 </script>
~~~

- 控制台输出：console.log(&quot;&quot;)
- 用户输入：prompt()语句

~~~html
 <cript type="text/javascript">
        var a = prompt("猜猜我会显示到哪里..."); //必须用一个变量来接收用户给的值
        console.log(a);
</script>
~~~


**3.window作用域**
只要在script标签中定义的变量，默认就在window的作用域之下
默认就是window这个对象里面写代码



### 3.2 JS语法知识

#### **3.2.1 变量**

​	变量本质是一个空盒子，里面记录了一个内存地址，使能找到内存中的对象，保存了指向具体的实在的东西的地址，变量存在栈中，对象存在堆中；

​	变量的意义：方便我们去操作对象。变量的几种引用方式

- 指针（C语言中叫法）
- 引用（Java）
- 变量

> 例如：
> var b = document.body 含义：把body这个对象在内存中的地址放到b变量里面，变量b（b是内存地址的别名）本身也存在内存中，以后的操作是针对body这个地址

​	变量命名规范

- 由字母(a-zA-Z)数字(0-9)下划线(_)以及美元符号($)
- 不能由数字开头
- 命名尽量用英文并且具有一定的含义
- 如果有多个英文单词，后面单词的首字母大写
- 不能使用关键字
- 首字母不要大写，大写是有特殊含义的



#### **3.2.2 JS数据类型**

**Javascript的数据类型有六种（ES6新增了第七种Symbol）**

- 数值（number）：整数和小数（比如1和3.14）
- 字符串（string）：字符组成的文本（比如”Hello World”）
- 布尔值（boolean）：true（真）和false（假）两个特定值
- undefined：表示 未定义 或不存在，即此处目前没有任何值
- null：表示空缺，即此处应该有一个值，但目前为空
- 对象（object）：各种值组成的集合

​        通常，我们将数值、字符串、布尔值称为原始类型（primitive type）的值，即它们是最基本的数据类型，不能再细分了。而将对象称为合成类型（complex type）的值，因为一个对象往往是多个原始类型的值的合成，可以看作是一个存放各种值的容器。至于undefined和null，一般将它们看成两个特殊值

内存中一共分为几种对象：1.变量		2.DOM对象		3.常量		4.自定义对象



#### **3.2.3 如何判断js中的数据类型**

==typeof、instanceof、 constructor、 prototype方法比较==

~~~js
如何判断js中的类型呢，先举几个例子：
var a = "i am string.";
var b = 222;
var c= [1,2,3];
var d = new Date();
var e = function(){alert(111);};
var f = function(){this.name="22";};
~~~

- 最常见的判断方法：typeof

~~~js
alert(typeof a)   ------------> string
alert(typeof b)   ------------> number
alert(typeof c)   ------------> object
alert(typeof d)   ------------> object
alert(typeof e)   ------------> function
alert(typeof f)   ------------> function

其中typeof返回的类型都是字符串形式，需注意，例如：
alert(typeof a == "string") -------------> true
alert(typeof a == String) ---------------> false
另外typeof可以判断function的类型；在判断除Object类型的对象时比较方便。
~~~



- 判断已知对象类型的方法：instanceof

~~~js
alert(c instanceof Array) ---------------> true
alert(d instanceof Date) ---------------> true
alert(f instanceof Function) ------------> true
alert(f instanceof function) ------------> false
注意：instanceof后面一定要是对象类型，并且大小写不能错，该方法适合一些条件选择或分支。
~~~



- 根据对象的constructor判断：constructor

~~~js
alert(c.constructor === Array) ----------> true
alert(d.constructor === Date) -----------> true
alert(e.constructor === Function) -------> true

注意： constructor 在类继承时会出错
例子：
function A(){};
function B(){};
A.prototype = new B(); //A继承自B
var aObj = new A();
alert(aobj.constructor === B) -----------> true;
alert(aobj.constructor === A) -----------> false;

而instanceof方法不会出现该问题，对象直接继承和间接继承的都会报true：
alert(aobj instanceof B) ----------------> true;
alert(aobj instanceof A) ----------------> true;

言归正传，解决construtor的问题通常是让对象的constructor手动指向自己：

aobj.constructor = A; //将自己的类赋值给对象的constructor属性
alert(aobj.constructor === A) -----------> true;
alert(aobj.constructor === B) -----------> false; //基类不会报true了;
~~~



- 通用但很繁琐的方法： prototype

~~~js
alert(Object.prototype.toString.call(a) === ‘[object String]’) ------> true;
alert(Object.prototype.toString.call(b) === ‘[object Number]’) ------> true;
alert(Object.prototype.toString.call(c) === ‘[object Array]’) -------> true;
alert(Object.prototype.toString.call(d) === ‘[object Date]’) -------> true;
alert(Object.prototype.toString.call(e) === ‘[object Function]’) ---> true;
alert(Object.prototype.toString.call(f) === ‘[object Function]’) ---> true;

大小写不能写错，比较麻烦，但胜在通用。
通常情况下用typeof判断就可以了，遇到预知Object类型的情况可以选用instanceof或constructor方法
~~~



#### **3.2.4 数据类型转换**

- **转换函数**
  - `toString()` 转换为字符串，在JavaScript中所有数据类型都可以转换为`string`类型
  - `parseInt()`解析出一个`string`或者`number`类型的整数部分，如果没有可以转换的部分，则返回`NaN`（`not a number`） 

  ~~~js
  var n1 = "12";
  var n2 = "23hello";
  var n3 = "hello";
  parseInt(n1); //12
  parseInt(n2); //23
  parseInt(n3); //NaN
  ~~~

  - parseFloat()解析出一个`string`的浮点数部分，如果没有可以转换的部分，则返回`NaN`（not a number）

~~~js
var n1 = "1.2.3";
var n2 = "1.2hello"
var n3 = "hello"
parseFloat(n1); //1.2
parseFloat(n2); //1.2
parseFloat(n3); //NaN
~~~

- ##### **强制类型转换**

  - ##### `Boolean(value)`- 把给定的值转换成`Boolean`型

  - ##### `Number(value)`-把给定的值转换成数字（可以是整数或浮点数）

  - ##### `String(value)`- 把给定的值转换成字符串 

- ##### **隐式转换**

  - 数字＋字符串：数字转换为字符串 console.log(12+"12"); //1212

  - 数字＋布尔值：true转换为1，false转换为0 console.log(12+true); //13

  - 字符串＋布尔值：布尔值转换为true或false 

    console.log("hello"+true); //hellotrue

  - 布尔值＋布尔值 console.log(true+true); //2

- **null和undefined**
  undefined 表示一种未知状态，声明了但没有初始化的变量，变量的值时一个未知状态。访问不存在的属性或对象window.xxx）方法没有明确返回值时，返回值是一个undefined.当对未声明的变量应用typeof运算符时，显示为undefined。
  null表示尚未存在的对象,null是一个有特殊意义的值。可以为变量赋值为null，此时变量的值为“已知状态”(不是undefined)，即null。（用来初始化变量，清除变量内容，释放内存）

  > undefined==null   //结果为true,但含义不同。
  > undefined===null //false,两者类型不一致，前者为“undefined”，后者为“object”



#### 3.2.5 **运算符**  

1.算术运算符(+,	-,	*,	/,	%,	++,	--)

- 字符串和数字相加的情况：
  - 左右都是数字：数字相加
  - 左右有一个字符串：字符串拼接
  - 左右边有一个null:null看做0
  - 左右边有一个undefined：结果是NAN(not a number)



2.赋值运算符(=, 	-=,	+=,	*=,	/=,	%=)

3.比较运算符(\==,	===,	!=,	>,	<,	>=,	<=)

> 先执行表达式计算再赋值
> \==和!=在比较之前首先让双方的值做隐士类型转换，===不转换



4.逻辑运算符(||,	&&,	   !)

- || 在js中和PHP中是不一样的 js中返回逻辑或的左边或右边的一个结果；PHP返回||或出来以后的结果即：true false

> 特殊性（注意）：一定要记住（这个特性和其他编程语言不一样）：在js里返回不是布尔值
>
> || 短路运算，第一个条件为真，后面不执行

- &&把表达式最后一个值返回（注意这里）

条件运算符`(表达式1?表达式2:表达式3)`三元运算符
==表达式1?表达式2:表达式3==，表达式1为真，返回表达式2，否则返回表达式3
三元运算符可以多层次嵌套使用

- **在js中，有四种被认为是非**：
  - `undefined`
  - `null`
  - `false`
  - `0`

例子：`var age = prompt("温馨提示：","请输入您的年龄")||0`

当点击取消的时候，如果出现`undefined` `null` `fasle` `0` 表示非的逻辑 那么`||`就会过滤，取右边的值`0`



#### 3.2.6循环

1.console.log调试程序，开发中大量使用这个 而不用`alert`

**js的断点调试方法：**
	1.运行程序，按F12键或者右键鼠标找到“检查”网页
	2.在弹出的窗体选择sources,点开源代码，在想要设置断点的地方的左边代码行单击设置断点
	3.然后要刷新一下页面，页面标题处于“圆圈”状态，表明进入调试模式
	4.拉开最右边的窗体，找到“watch”，可以添加想要检测的变量。

2.条件结构
if
if...else
if...else if...else
当通过判断返回某个值的时候，优先使用三元表达式
当通过判断执行N段逻辑代码的时候，只能用条件结构

3.switch
switch case break default 条件 判断 退出 默认

- a.只要匹配上一个case，那么它下面的所有的case都会执行包括default
- b.break的意思跳出当前结构

4.for

循环有三个要素

- a.循环变量
- b.判断（循环体）
- c.改变循环变量

> continue 结束本次循环，继续下一次循环，当前这次循环不做，直接做下面的
> break 跳出本层循环（只跳出一层）



**5.while/do...while 没有谁好谁坏 只有适应场景不同**

- 比如：先吃饭 在买单 do..while 用户体验高 有风险 扫雷游戏也是先体验 在问是否退出 提高体验
- 比如：先买单 在吃饭 while 用户体验不高



> 一般情况下面，如果条件判断是数字的比较`==	<>`，for循环优先.
> 如果是非数值相关的比较循环，while优先



#### 3.2.7 Object对象

1.JS对象

​	JS对象有内置对象，宿主对象（JS运行环境提供的对象 BOM DOM）和用户自定义对象，自定义对象通过new关键字来创建，之后内存会为对象开辟一个新的内存空间，位于堆(heap)里面；
	for...in 语句循环遍历对象的属性。

new关键字代表的是新开辟一块内存空间，没有被引用的内存空间，会在适当的时候被销毁

以下两句代码含义等同

- var person = new Object();
- var person = {};

访问对象的属性除了用 对象引用`.属性 key`以外，还可以使用对象引用`[属性key]`

~~~js
<body>
		<!--prototype 属性允许您为对象构造器添加新属性：-->
		<script type="text/javascript">
			function Person(){
				name="hello";
				age=11;
			}
			Person.prototype.nation="中国";
			Person.prototype.eyecolor="black";
			//构造器可以通过 构造器名.prototype 来拿到，或者添加原型属性/方法
			//由Person构造器实例化的对象通过.__proto__ 去拿到或者添加原型属性。
			var p1=new Person();
			var p2=new Person();
			//alert(Person.prototype == p1.__proto__);
			p1.__proto__.eyecolor="黑色";
			//alert(p2.__proto__.eyecolor);
			
			/*你也可以直接通过对 象名.属性名 去拿到构造器中已有的原型属性
			如果对象本身就有,则直接使用,如果没有,对象会自动向上查找(构造器)
			如果最后构造器中也没有,才会返回undefined*/
			//alert(p1.nation);
			alert(p1.hhh+"没找到此属性");
			
			//var arr=[1,2,3,5];
			var arr=new Array();  
			arr[0]=1;
			arr[1]=2;
			arr[2]=3;
			for (var s in arr) {  //此时s就代表arr数组的下标
				alert(arr[s]);    //通过arr[下标]就可以得到数组的元素值
			}
		</script>
	</body>
~~~



2.new 原理详细解析

------

- 无论什么时候，只要创建一个新函数，就会根据一组特定的规则为该函数创建一个`prototype`属性，这个属性指向函数的原型对象。
- 在默认情况下，所有原型对象都会自动获得一个`constructor`（构造函数）属性，这个属性包含一个指向`prototype`属性所在函数的指针（就是指向新创建的函数）。
- 通过这个构造函数（原型对象的构造函数），可以继续为原型对象添加其他属性和方法。
- 当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。`ECMA-262`第5版管这个指针叫 `[[Prototype]]`。脚本中没有标准的方式访问`[[Prototype]]`，但`Firefox`、`Safari`和`Chrome`在每个对象上都支持一个属性`__proto__`；而在其他实现中，这个属性对脚本是完全不可见的。不过，要明确的真正重要的一点就是，这个连接存在于实例和构造函数的原型对象之间，而不是存在于实例和构造函数之间



3.new创建对象的步骤

------

- 创建一个新的对象
- 将构造函数的作用域赋给新对象
- 执行构造函数的代码，为这个新对象添加属性
- 返回新对象



**4.使用工厂方法创建对象**

~~~js
使用工厂方法创建对象，通过该方法可以大批量的创建对象
			function createPerson(name , age ,gender){
				//创建一个新的对象 
				var obj = new Object();
				//向对象中添加属性
				obj.name = name;
				obj.age = age;
				obj.gender = gender;
				obj.sayName = function(){
					alert(this.name);
				};
				//将新的对象返回
				return obj;
			}
			var obj2 = createPerson("猪八戒",28,"男");
			var obj3 = createPerson("白骨精",16,"女");
			var obj4 = createPerson("蜘蛛精",18,"女");
			/*
			 * 使用工厂方法创建的对象，使用的构造函数都是Object
			 * 	所以创建的对象都是Object这个类型，
			 * 	就导致我们无法区分出多种不同类型的对象
			 */
~~~



**5.构造器**

~~~js
<script type="text/javascript">
		//构造器constructor
		function person(name,age,sex){
			this.name=name;
			this.age=age;
			this.sex=sex;
			this.work=function () {
				alert("人都要工作");
			};
		}
		var tom=new person("tom",23,"男");
		var bill=new person("bill",25,"男");
		var jessie=new person("jessie",20,"女");
		//tom instanceof person 表示判断左边的对象是否属于右边的类
		alert(tom instanceof person);  //true
	</script>
~~~



### 3.3 BOM 浏览器对象模型

- a.screen 指的不是浏览器的宽度，指的是整个电脑屏幕的分辨率，可以拿到屏幕可用分辨率
- b.navigator，可以通过userAgent判断当前浏览器信息
- c.location。URL：统一资源定位符 Union Resource Location

可以通过href属性重定向（改变）页面的URL，进行页面跳转

- d.history。go方法能够让我们进行历史回退或者前进
- e.frames。获得当前窗体的子页面（iframe）
- f.document。DOM模型的核心对象



### 3.4 DOM文档对象模型

------

- **document**

  - 功能
    - `getElementById` `$('#aaa')`
    - `getElementByTagName` `$('div')`
    - `getElementsByClassName` `$('.aaa')`
    - `getElementsByName` 只用在表单元素中

- **document object**

  - 属性：
    - `className`，`style`
    - `id`
    - `name`,`value`(表单元素)
    - `href`,`src`…(对应的元素)
    - `innerHTML`
    - `children`
    - `parentNode`

  - 功能方法：
    - `setAttribute/getAttribute`
    - `appendChild`

**1.DOM与节点的关系：**

------

- node:
  - `childNodes[]`
  - `parentNode`
  - `firstChild`
  - `getElementsByTagName('元素标签')`
  - `lastchild`
  - `nextSibling`
  - `previousSibling`
  - `children[index]` `children` 不是`w3c`标准 但是各大浏览器兼容性很好

- 通过给原型添加方法在元素后面创建标签



**2.DOM方法小结**

------

- `cloneNode` 返回当前节点的拷贝
- `createAttribute` 创建新的属性
- **插入节点**

- - `node.insertBefore()`
  - `node.insertAdjacentElement()`
- **删除节点**
  - `node.remove()`
  - `node.removeChild()`
  - `node.removeNode()`
- **替换节点**
  - `node.replaceChild()`
  - `node.replaceNode()`
  - `node.swapNode()`



- `node.cloneNode(bAll)`返回复制复制节点引用
- `node.contains()` 是否有子节点
- `node.hasChildNodes()`是否有子节点

**3.常用事件**

***

- `onclick:`当事件源被点击的时候调用处理程序
- `onmouseover:`鼠标进入事件
- `onmouseout:`鼠标移出事件
- `onmousedown:`鼠标按下去的时候
- `onmouseup:`鼠标抬起来的时候
- `onscroll:`当事件源滚动条滚动的时候
- `onkeydown:`当键盘按下的时候
- `onkeypress:`当键盘按下去的时候
- `onkeyup:`当键盘弹上来的时候
- `onfocus:`当事件源获得光标
- `onblur:`当事件源失去光标
- `onchange:`当事件源`blur`的时候内容改变了的话



### 3.5 JSON相关

 #### 3.5.1 json简介
​	JSON全称&quot;JavaScript Object Notation&quot;,意思是JavaScript对象表示法，它是一种基于文本，独立于语言的轻量级数据交换格式。XML也是一种数据交换格式，为什么没有选择XML呢？因为XML虽然可以作为跨平台的数据交换格式，但是在JS中处理XML非常不方便，同时XML标记比数据多，增加了交换产生的流量，而json没有附加任何标记，在JS中可作为对象处理，所以更倾向于JSON来交换数据。
#### 3.5.2 json的两种结构
​	json简单说就是javascript中的对象和数组，所以这两种结构就是对象和数组两种结构，通过这两种结构可以表示各种复杂的结构。

1、对象：对象在js中表示为“{}”括起来的内容，数据结构为 {key：value,key：value,...}的键值对的结构，在面向对象的语言中，key为对象的属性，value为对应的属性值，所以很容易理解，取值方法为 对象.key 获取属性值，这个属性值的类型可以是 数字、字符串、数组、对象几种。

```
var jsonObj = { "name": "tom", "age": 12 }
```



2、数组：数组在js中是中括号“[]”括起来的内容，数据结构为 ["java","javascript","vb",...]，取值方式和所有语言中一样，使用索引获取，字段值的类型可以是 数字、字符串、数组、对象几种。

```
var jsonArr = [
            { "id": 1, "name": "john" },
            {"age":13,"address":"str1"}
        ]
```

经过对象、数组 这2种结构就可以组合成复杂的数据结构了。



#### 3.5.3 json字符串

~~~
var Str = "this is a String";    //字符串
var jsonObj = {Name:"dick",age:"20",ID:"160512"};    //json对象
var jsonStr = "{Name:"dick",age:"20",ID:"160512"}";    //json字符串
//json字符串指的是符合json格式要求的js字符串
~~~
#### 3.5.4 在JS中如何使用JSON
​	JSON是JS的一个子集，所以可以在JS中轻松地读，写JSON。读和写JSON都有两种方法，分别是利用”.”操作符和“\[key\]”的方式。  
我们首先定义一个JSON对象，代码如下。
~~~
var obj = {
              1: "value1",
            "2": "value2",
            count: 3,
            person: [ //数组结构JSON对象，可以嵌套使用
                        {
                            id: 1,
                            name: "张三"
                        },
                        {
                            id: 2,
                            name: "李四"
                        }
                   ],
            object: { //对象结构JSON对象
                id: 1,
                msg: "对象里的对象"    
            }
        };
~~~
1，从JSON中读数据
~~~
function ReadJSON() {
           alert(obj.1); //会报语法错误，可以用alert(obj["1"]);说明数字最好不要做关键字
            alert(obj.2); //同上

            alert(obj.person[0].name); //或者alert(obj.person[0]["name"])
            alert(obj.object.msg); //或者alert(obj.object["msg"])
        }
~~~
2，向JSON中写数据
比如要往JSON中增加一条数据，代码如下：
~~~
function Add() { 
            //往JSON对象中增加了一条记录
            obj.sex= "男" //或者obj["sex"]="男"
        }
~~~
增加数据后的json对象如图
![](https://box.kancloud.cn/c8ffe3be26768e21eeab68300a8e2e76_559x146.png)



3，修改JSON中的数据
我们现在要修改JSON中count的值，代码如下：

~~~
function Update() {
            obj.count = 10; //或obj["count"]=10
        }
~~~
4，删除JSON中的数据
我们现在实现从JSON中删除count这条数据，代码如下：
~~~
function Delete() {
            delete obj.count;
        }
~~~


5，遍历JSON对象

可以使用for…in…循环来遍历JSON对象中的数据，比如我们要遍历输出obj对象的值，代码如下：

```
function Traversal() {
            for (var c in obj) {
                console.log(c + ":", obj[c]);
            }
        }
```

程序输出结果为：

![json04](https://images0.cnblogs.com/blog/311549/201306/08225707-40f4c05d2ae644368f4af6f281035220.jpg)





## 第四章 jQuery

### 4.1 概述

1.什么是jquery

​	JQuery 对 js 做了封装。jQuery 由美国人 John Resig 创建，至今已吸引了来自世界各地的众多，javascript 高手加入其 team。其宗旨是——WRITE LESS,DO MORE,写更少的代码,做更多的事情。它是轻量级的 js 库(压缩后只有 21k) ，还兼容各种浏览器 。jQuery 是一个快速的，简洁的 javaScript，库，使用户能更方便地处理 HTML documents、events、实现动画效果，并且方便地为网站提供 AJAX 交互。jQuery 还有一个比较大的优势是，它的文档说明很全，而且各种应用也说得很详细，同时还有许多成熟的插件可供选择。

2.jquery 的引入

JQuery 的 js 文件：（MyEclipse 中引入压缩版会报错，但可使用）

![1564883615846](C:\Users\Administrator\AppData\Local\Temp\1564883615846.png)

Jquery 的引入：

~~~html
<%@ page language="java" contentType="text/html; charset=UTF-8"
pageEncoding="UTF-8"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>
<c:set var="path" value="${pageContext.request.contextPath }">/c:set
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<script type="text/javascript" src="${path }/js/jquery-1.8.3.js">		</script>
	<!--强烈建议使用绝对路径-->
	<title>Insert title here</title>
	</head>

	<body>

	</body>

</html>

~~~



3.jquery的主函数

第一种方式：

~~~html
<script type="text/javascript">//先来定义 jquery 的主函数。jquery 的主函数的含义在于把整个文档加载完毕后再去执行主函数。
    $(document).ready(function()
       var div1 = document.getElementById("div1");
       alert(div1);
    });
</script>
~~~

第二种方式(建议使用)：

~~~html
<script type="text/javascript">
$(function(){
...
})
</script>
~~~



**4.Jquery 对象**
	jQuery对象就是通过 jQuery包装 DOM 对象后产生的对象。Jquery对象能和 DOM 对象之间做一些转换。jQuery对象是jQuery 独有的. 如果一个对象是jQuery对象, 那么它就可以使用jQuery里的方法。虽然jQuery对象是包装 DOM 对象后产生的，但是 jQuery无法使用 DOM 对象的任何方法，同理 DOM 对象也不能使用jQuery里的方法，乱使用会报错。

- **DOM 对象转成 jQuery 对象**

		对于已经是一个 DOM 对象，只需要用$()把 DOM 对象包装起来，就可以获得一个 jQuery 对象了。$(DOM 对象) 。转换后就可以使用 jQuery 中的方法了。

~~~html
<script type="text/javascript" src="${path }/js/jquery-1.8.3.js"></script>
<script type="text/javascript">
function myclick(){
    var myinput = document.getElementById("myinput");
	var jq_myiput = $(myinput);
    alert(jq_myiput.val());
}
</script>
</head>

<body>

<input type="text" id="myinput">
<input type="button" value="submit" onclick="myclick()">
</body>

//为什么点击触发事件后能获取到 myinput？因为当点击提交按钮时文档已经加载完。
~~~



**JQuery 对象转换成 dom 对象（很少用）**

~~~js
function myclick(){
	var div1 = document.getElementById("myinput"); //把dom转换成jQuery对象
	var jdiv1 = $(div1); //jdiv是一个数组。
//把jQuery对象转换成dom对象方式1： jQuery对象是一个数组对象，可以通过[index]的方法，来得到相应的DOM对象

	alert(jdiv1[0].value);
//把jQuery对象转换成dom对象方式2： jQuery本身提供，通过.get(index)方法，得到相应的DOM对象

	alert(jdiv1.get(0).value);
}
~~~



### 4.2 jQuery 选择器

​	选择器用来获取文档上的 DOM 对象的元素，然后把它转成 jquery 对象，最重要的就是操纵 dom 元素，获取值、设置值、形成一些动态的效果都需要使用选择器。选择器是 jQuery 的根基, 在 jQuery 中, 对事件处理, 遍历 DOM 和 Ajax 操作都依赖于选择器。
jQuery 选择器的优点:

简洁的写法： 

`$(“#id”)` 等价于 `document.getElementById("id");`
`$(“tagName”)` 等价于 `document.getElementsByTagName("tagName");`



**1.基本选择器：**
	基本选择器是 jQuery 中最常用的选择器, 也是最简单的选择器, 它通过元素 id, class 和标签名来查找DOM 元素。

![img](https://box.kancloud.cn/7fe1d180bd64d977435b7e5b20999a7d_565x534.png) 



**2.层次选择器**
	如果想通过 DOM 元素之间的层次关系来获取特定元素, 例如后代元素, 子元素, 相邻元素, 兄弟元素

![img](https://box.kancloud.cn/55c30069d80fd5b06c0d2e271a12cd36_560x451.png) 



**3.基本过滤选择器**

![img](https://box.kancloud.cn/4eb271d8075526c859d1b61e1116d087_443x563.png)



**4.属性过滤选择器**

​	属性过滤选择器的过滤规则是通过元素的属性来获取相应的元素。

- 用法: $(”div[id]“) ; 返回值 集合元素

> 说明: 匹配包含给定属性的元素. 例子中是选取了所有带”id”属性的 div 标签.

- [attribute=value]
- 用法: $(”input[name='newsletter']“).attr(”checked”, true); 返回值 集合元素

> 说明: 匹配给定的属性是某个特定值的元素.例子中选取了所有 name 属性是 newsletter 的 input 元素

- [attribute!=value]
- 用法: $(”input[name!='newsletter']“).attr(”checked”, true); 返回值 集合元素

> 说明: 匹配所有不含有指定的属性，或者属性不等于特定值的元素.此选择器等价于`:not([attr=value])`,要匹配含有特定属性但不等于特定值的元素,请使用`[attr]:not([attr=value])`.之前看到的 :not 派上了用场

- [attribute^=value]
- 用法: $(”input[name^=‘news’]“) 返回值 集合元素

> 说明: 匹配给定的属性是以某些值开始的元素

- [attribute$=value]
- 用法: $(”input[name$=‘letter’]“) 返回值 集合元素

> 说明: 匹配给定的属性是以某些值结尾的元素

-  [attribute*=value]
- 用法: $(”input[name*=‘man’]“) 返回值 集合元素

> 说明: 匹配给定的属性是以包含某些值的元素

-  \[attributeFilter1]\[attributeFilter2][attributeFilterN]
- 用法: $(”input\[id][name$=‘man’]“) 返回值 集合元素

> 说明: 复合属性选择器,需要同时满足多个条件时使用.又是一个组合,这种情况我们实际使用的时候很常用.这个例子中选择的是所有含有 id 属性,并且它的 name 属性是以 man 结尾的元素



**5.子元素过滤选择器**

```
$("div.one :nth-child(2)")  //选择class为one的div的第二个子元素
$("div.one :first-child")    //选择class为one的div的第一个子元素
$("div.one :last-child")    //选择class为one的div的最后一个子元素
$("div.one :only-child")    //选择class为one的div的唯一子元素
```

内容选择器

```
$("div:contains('di')")     //选择内容包含‘di’的div
$("div:empty")    //选择不包含文本的空div
$("div:has(div.mini)")    //选择含有class叫div的div元素
```



**6.查找选择器**

![img](https://box.kancloud.cn/2734260159d46a7563c1b4d8b118e032_497x285.png)

**nextAll（expression）**

```
//查找当前元素之后所有的同辈元素。
$("#one").nextAll("span:first")    //查找id为one元素后面第一个span元素
```

**preAll（expression）**

```
//查找当前元素之前所有的同辈元素
$("#two").prevAll("div")    //查找id为two元素前面所有div元素
```



### 4.3 文档处理

​	Jquery 操作 dom。DOM(Document Object Model—文档对象模型)：一种与浏览器, 平台, 语言无的接口, 使用该接口可以轻松地访问页面中所有的标准组

-  append(content) :向每个匹配的元素的内部的结尾处追加内容 
- appendTo(content) :将每个匹配的元素追加到指定的元素中的内部结尾处 
- prepend(content):向每个匹配的元素的内部的开始处插入内容 
- prependTo(content) :将每个匹配的元素插入到指定的元素内部的开头



外部插入节点:（应用：增加一行、做校验等）

- after(content) :在每个匹配的元素之后插入内容
- before(content):在每个匹配的元素之前插入内容



删除节点

- remove(): 从 DOM 中删除所有匹配的元素, 传入的参数用于根据 jQuery 表达式来筛选元素. 当某个节点用 remove() 方法删除后, 该节点所包含的所有后代节点将被同时删除. 这个方法的返回值是一个指向已被删除的节点的引用.

- empty(): 清空节点 – 清空元素中的所有后代节点(不包含属性节点)



### 4.4 属性操作

- attr(): 获取属性和设置属性
- removeAttr(): 删除指定元素的指定属性

当为该方法传递一个参数时, 即为某元素的获取指定属性。当为该方法传递两个参数时, 即为某元素设置指定属性的值。

jQuery 中有很多方法都是一个函数实现获取和设置. 如: 1. attr(), 2. html(),

3. text(), 4. val(), <u>height(), width()不常用,</u> 5.css() 等.



### 4.5 练习

- **练习 1：鼠标点进去内容就消失，鼠标移出来内容就展示**

![1564887348553](C:\Users\Administrator\AppData\Local\Temp\1564887348553.png)

~~~html
<script type="text/javascript">
	function myfocus(obj){
	//当聚焦时获得文本框的值
	var value = $(obj).val();
	//如果值是 "请输入用户名/电话/邮箱"
	if(value == "请输入用户名/电话/邮箱"){
	//把值变为空
	$(obj).val("");
	//为了让输入的内容是黑色的字，把样式去掉
	$(obj).removeClass();
	}
}
	function myblur(obj){
	//离开焦点时，如果没有输入内容
	if($(obj).val() == ""){
	//把 "请输入用户名/电话/邮箱" 再添回去
	$(obj).val("请输入用户名/电话/邮箱");
	//再把灰色的字变回来
	$(obj).addClass("c1");
	}
}
/* 当鼠标点击紧文本框后没输入然后在点出， "请输入用户名/电话/邮箱" 会显示为黑体。当鼠标点
击紧文本框输入内容后，当鼠标点出时输入的内容会变灰色。
此句$(obj).addClass("c1");应该和 添回去的"请输入用户名/电话/邮箱" 写一起。
function myfocus(obj){
	var value = $(obj).val();
	if(value == "请输入用户名/电话/邮箱"){
	$(obj).val("");
	$(obj).removeClass();
	}else{
	$(obj).addClass("c1");
	}
}
	function myblur(obj){
	if($(obj).val() == ""){
	$(obj).val("请输入用户名/电话/邮箱");
	}
} */
</script>
<style type="text/css">
	.c1{
	color:gray;
	}
</style>
</head>
<body>
	用户名：<input type="text" value="请输入用户名/电话/邮箱" class="c1"
	onfocus="myfocus(this)" onblur="myblur(this)">
</body>
~~~



- **练习 2：tab 页**

~~~html
<script type="text/javascript">
	$(function(){
	//初次访问是第一个 li 的 border-bottom 为#B0BFD4。获得第一个 li
	$("li:first").css("border-bottom","2px solid #B0BFD4");
	$("li").click(function(){
		//把所有 border-bottom 变为 white。
		$("li").each(function(){
		$(this).css("border","2px solid white");
		})
		//把点击到的 li 的 border-bottom 为#B0BFD4。
		$(this).css("border-bottom","2px solid #B0BFD4");
		//获得 li 的自定义属性 tab
		var tab = $(this).attr("tab");
		//把所有 div 都隐藏
		$(".divTab").hide();
		//显示点击的 div
		$("#"+tab).show();
		})
	})
</script>
<style type="text/css">
	li{
	list-style: none;
	width:60px;
    height:30px;
    background:#B0BFD4;
    text-align:center;
    float:left;
    border:2px solid white;
	}
    .divTab{
    width:400px;
    height:200px;
    background:#B0BFD4;
    }
</style>
</head>
<body>
    <!--list-style: none;去掉 li 内容前的点;
    clear:both; 清除 li 浮动对 div 的影响-->
    <ul>
        <li tab="div1">页签 1</li>
        <li tab="div2">页签 2</li>
        <li tab="div3">页签 3</li>
    </ul>
    <div style="clear:both;"></div>
    <div class="divTab" id="div1">div1</div>
    <div class="divTab" style="display: none;" id="div2">div2</div>
    <div class="divTab" style="display: none;" id="div3">div3</div>
</body>
~~~

![1564887787059](C:\Users\Administrator\AppData\Local\Temp\1564887787059.png)





## 第五章 AJAX

### 5.1 认识Ajax

**1.什么是Ajax**

---

AJAX（Asynchronous Javascript And XML）翻译成中文就是“异步的Javascript和XML”

- Ajax不是某种编程语言，而是一种在无需重新加载整个网页的情况下，能够**局部更新**网页的技术。

**2.Ajax常见应用场景**

---

搜索引擎根据用户输入的关键字，自动提示检索关键字。
还有一个很重要的应用场景就是注册时候的用户名的查重。
其实这里就使用了AJAX技术！当文件框发生了输入变化时，使用**AJAX技术向服务器发送一个请求**，然后服务器会把查询到的结果响应给浏览器，最后再把后端返回的结果展示出来。

- 整个过程中页面没有刷新，只是刷新页面中的局部位置而已！
- 当请求发出后，浏览器还可以进行其他操作，无需等待服务器的响应！
  ![img](https://box.kancloud.cn/32974dc8b907d89de4143427c8d1fcb8_589x288.png)
  当输入用户名后，把光标移动到其他表单项上时，浏览器会使用AJAX技术向服务器发出请求，服务器会查询名为lemontree7777777的用户是否存在，最终服务器返回true表示名为lemontree7777777的用户已经存在了，浏览器在得到结果后显示“用户名已被注册！”。
- 整个过程中页面没有刷新，只是局部刷新了；
- 在请求发出后，浏览器不用等待服务器响应结果就可以进行其他操作；

**3.Ajax优点**

---

- AJAX使用JavaScript技术向服务器发送异步请求；

- AJAX请求无须刷新整个页面；
- 因为服务器响应内容不再是整个页面，而是页面中的部分内容，所以AJAX性能高；



### 5.2 使用ajax

**1.传统javascript使用ajax方式：** 

​	XMLHttpRequest对象：所有现代浏览器均支持XMLHttpRequest对象，XMLHttpRequest用于在后台与服务器交换数据。 

~~~js
function getInfo()
{
	var xmlhttp;
	if (window.XMLHttpRequest){
            // IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码
		xmlhttp=new XMLHttpRequest();
	}else{	// IE6, IE5 浏览器执行代码
	    xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
	}
	xmlhttp.onreadystatechange=function(){
	    if (xmlhttp.readyState==4 && xmlhttp.status==200){
                 var str = xmlhttp.responseText;
                 alert(str);
	    }
	}
	xmlhttp.open("GET","/url",true);
	xmlhttp.send();
}
~~~

使用 A JAX 的过程可以类比平常我们访问网页过程

- 创建一个 XMLHttpRequest 类型的对象 —— 相当于打开了一个浏览器

var xmlhttp=new XMLHttpRequest();

- 打开与一个网址之间的连接 —— 相当于在地址栏输入访问地址

xmlhttp.open("GET","/url",true);

- 通过连接发送一次请求 —— 相当于回车或者点击访问发送请求

xmlhttp.send();

- 指定 xhr 状态变化事件处理函数 —— 相当于处理网页呈现后的操作

> xmlhttp.onreadystatechange = function () {
> //通过 xmlhttp 的 readyState 判断此次请求的响应是否接收完成
> if (this.readyState === 4) {
> //通过 xmlhttp的 responseText 获取到响应的响应体
> console.log(this)
> }

readyState从 0 到 4 发生变化。

- 0: 请求未初始化
- 1: 服务器连接已建立
- 2: 请求已接收
- 3: 请求处理中
- 4: 请求已完成，且响应已就绪

status为访问状态，404 页面没找到， 500 内部错误， 200访问正常等。

- 1xx  -消息: 请求正在处理，请稍后。。。
- 2xx -成功处理
- 3xx -重定向到其他地方: 需要客户端再次发送请求
- 4xx -客户端错误，eg: 非法的资源请求，禁止访问
- 5xx -服务器段错误 ，eg: 服务器抛出异常

在Java中将处理结果的字符串，一般是以JSON字符串返回，存储在前端xmlhttp.responseText中。



**2.jQuery写法：**

jquery将上述写法进行了封装，使得我们更加简单和方便的去使用ajax。常见用法：

~~~js
$.ajax(function(){
    type: "post",
    url : "url",
    data: {"name":"Peter"}, 
    success:function(data, status){
       //处理
    },
    error:function(){
       //error有三个参数，可以依据情况需要写
    }
~~~



**3.$.ajax()**

```
window.onload = function(){
$.ajax({
    type:"get",
    url:"xx",
    dataType:"json",
    success:function(data){
        console.log(data);
    },
    error:function(xhr){
        document.body.innerHTML = xhr.status;
    }
})
```



**4.$.get()**

```
//$.get()语法
$.get(url,function(data,status){
//获取的data是一个JS对象

}).fail(function(data){
	console.log(data.status)
})
```



**5.$.post()**

```
//$.post()语法
$.post(url,data,function(data,status){

}).fail(function(data){
    console.log(data.status)
})
```

 

**6.应用**

---

~~~html
public class ValidSameServlet extends HttpServlet {
	protected void doGet(HttpServletRequest req, HttpServletResponse resp)
		throws ServletException, IOException {
	doPost(req, resp);
	}
	protected void doPost(HttpServletRequest req, HttpServletResponse resp)throws ServletException, IOException {
		//获得 ajax 发送的数据
		String name = req.getParameter("username");
		if("12345".equals(name{
			resp.getWriter().print("yes");
		}else{
			resp.getWriter().print("no");
		}
	}
}

<script type="text/javascript">
    $(function(){
        $("form input").blur(function(){
            //离开焦点的 input 是哪个这个 this 就是哪个对象
            var obj = $(this);
            var val = obj.val();
            var reg = obj.attr("reg");
            var tip = obj.attr("tip");
            var name = obj.attr("name");
            var regObj = new RegExp(reg);
            if(!regObj.test(val)){
                //获得 username 紧挨着的下一个dom的jQuery对象
                var spanObj = obj.next();
                spanObj.html("<font color='red'>"+tip+"</font>");
            }else{
                var spanObj = obj.next();
                if(name == "username"){
                    //ajax 的重复性校验
                    var result = validSame(val);
                    if(result == "yes"){
                        spanObj.html("<font color='red'>用户名已经存在</font>");
                    }else{
                        spanObj.html("");
                    }
                }else{
                    spanObj.html("");
                }
            }
        });
        /*查询用户名是否重复，no 不重复，yes 重复*/
        function validSame(val){
            var isSame = "no";
            $.ajax({
                type:'post',
                url:'${path}/validsame',
                async:false,
                data:{username:val},
                dataType:"text",
                success:function(result){
                    isSame = result;
                },
                error:function(){
                    alert("系统错误");
                }
            });
            return isSame;
        }
        
        $("form input").focus(function(){
            $(this).css("background","yellow");
        });
        //一边输入一边校验。
        $("form input").keyup(function(event){
            /* var num = window.event?event.keyCode : event.which;var charStr = String.fromCharCode(num); */
            var obj = $(this);
            var val = obj.val();
            var reg = obj.attr("reg");
            var tip = obj.attr("tip");
            var name = obj.attr("name");
            var regObj = new RegExp(reg);
            if(!regObj.test(val)){
                //获得 username 紧挨着的下一个 dom 的 jQuery 对象
                var spanObj = obj.next();
                spanObj.html("<font color='red'>"+tip+"</font>");
            }else{
                var spanObj = obj.next();
                if(name == "username"){
                    //ajax 的重复性校验
                    var result = validSame(val);
                    if(result == "yes"){
                        spanObj.html("<font color='red'>用户名已经存在</font>");
                    }else{
                        spanObj.html("");
                    }
                }else{
                    spanObj.html("");
                }
            }
        });
        /* $("#regist").click(function(){
        //设置一个提交表单的标志
        var isSubmit = true;
        $("form input").each(function(){
        	var obj = $(this);
        	var val = obj.val();
        	var reg = obj.attr("reg");
        	var tip = obj.attr("tip");
        	var regObj = new RegExp(reg);
        	if(!regObj.test(val)){
        		//获得 username 紧挨着的下一个 dom 的 jQuery 对象
        		var spanObj = obj.next();
        		spanObj.html("<font color='red'>"+tip+"</font>");
        		isSubmit =false;
        		}else{
        		var spanObj = obj.next();
        		spanObj.html("");
        		}
        	})
        	if(isSubmit){
        		//表单提交
        		$("#myform").submit();
        		}
        	}) */
        $("#myform").submit(function(){
            var isSubmit =true;
            $("form input").each(function(){
                var obj = $(this);
                var val = obj.val();
                var reg = obj.attr("reg");
                var tip = obj.attr("tip");
                var name = obj.attr("name");
                var regObj = new RegExp(reg);
                if(!regObj.test(val)){
                    //获得 username 紧挨着的下一个 dom 的 jQuery 对象
                    var spanObj = obj.next();
                    spanObj.html("<font color='red'>"+tip+"</font>");
                    isSubmit =false;
                }else{
                    var spanObj = obj.next();
                    if(name == "username"){
                        //ajax 的重复性校验
                        var result = validSame(val);
                        if(result == "yes"){
                            spanObj.html("<font color='red'>用户名已经存在</font>");
                            isSubmit =false;
                       }else{
                           spanObj.html("");
                       }
                    }else{
                        spanObj.html("");
                    }
                }
            })
            //阻止表单提交，如果是 true 就允许表单提交
            return isSubmit;
        });
        $("#gender").change(function(){
            //获得改变后的值
            var val = $(this).val();
            alert(val)
        });
        
        $("body").keydown(function(event){
            var num = window.event?event.keyCode : event.which;
            if(num == 13){
                var isSubmit = true;
                $("form input").each(function(){
                    var obj = $(this);
                    var val = obj.val();
                    var reg = obj.attr("reg");
                    var tip = obj.attr("tip");
                    var name = obj.attr("name");
                    var regObj = new RegExp(reg);
                    if(!regObj.test(val)){
                        //获得 username 紧挨着的下一个 dom 的 jQuery 对象
                        var spanObj = obj.next();
                        spanObj.html("<fontcolor='red'>"+tip+"</font>");
                        isSubmit =false;
                    }else{
                        var spanObj = obj.next();
                        if(name == "username"){
                            //ajax 的重复性校验
                            var result = validSame(val);
                            if(result == "yes"){
                                spanObj.html("<font color='red'>用户名已经存在</font>");
                                isSubmit =false;
                        }else{                           
                            spanObj.html("");
                             }
                        }else{
                            spanObj.html("");
                        }
                    }
                })
                if(isSubmit){
                    //表单提交
                    $("#myform").submit();
                }
            }
        });
    })
</script>

</head>
<body><form id="myform" action="${path }/jsp2/tab.jsp" method="post">
    <p>
        用户名：<input id="username" name="username" 			type="text"reg="^\d{3,5}$"
        tip="请输入 3 到 5 位的数字">
        <span></span>
    </p>
    <p>密码：<input name="password" type="password" reg="^\w{6,8}$" tip="请输入 6 到 8位的英文或者数字或_"><span></span>
    </p>
    <p>地址：<input name="address" type="text" reg="^.{0,50}$" tip="请输入 50 个字符"><span></span></p>
    <p>性别：<select id="gender">
        <option value="1">男</option>
        <option value="2">女</option>
        </select><span></span>
    </p>
    <p><input type="submit" value="注册" id="regist"></p>
    </form>
</body>
~~~



